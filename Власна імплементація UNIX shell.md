#### Життєвий цикл shell
1. Ініціалізація
	На цьому етапі shell зчитує конфігураційні файли та змінює свою поведінку відповідно до них.
2. Виконання
	Тут оболонка читає та виконує команди з stdin або файлу.
3. Завершення
	Після того, як всі команди виконані shell виконує всі кроки(команди) завершення роботи, звільняє пам'ять та закінчує процес.

Взагалі ці кроки життєвого циклу настільки узанілтнені, що можуть бути застосовані до, буквально, будь-якої програми. В даному випадку моя оболонка буде дещо зпрощена. Вона не буде мати конфігураційних файлів та команд завершення. На першому етапі mshell буде складатись з основного чиклу роботи в якому будуть виконуватись команди, що вводяться вручну. Хоча, на кроці проектування архітектури програми варто продумати наперед можливість розширення функціональності, що в себе включє вище згадані конф. файли та shutdown commands. 

```C 
int main(char **argv, int argc) {
	// TODO: Load configuration files
	
	// Main shell loop
	mshell_loop();
	
	// TODO: Execute termination routines
	
	return 0;
}
```
Вище можна побачити базову структкру програми. Моя програма буде складатись з основного циклу `mshell_loop()` в якому відбуватимуться всі необхідні операції для виконання команд. В наступних параграфах ми більш детально їх оглянемо. 
#### Основний цикл shell
В попередньому параграфі ми обговорили: як повинна запускатись програма, що вона повинна виконувати під час роботи, так як завершуватись. Отже, що нам потрібно для базового функціонування shell? Що конкретно shell робить під час циклу? Власне найпростіша імплементація оболонки включає в себе такі три кроки:
- Read: читання команд з stdin.
- Parse: розділення стрічки команди на програму та її аргументи.
- Execute: виконання визначених команд.
```C
void mshell_loop() {
	char *line;
	char **args;
	int8_t status;
	
	do {
		printf("> ");
		line = mshell_read_line();
		args = mshell_split_line(line);
		status = mshell_execute(args);
		  
		free(line);
		free(args);
	} while (status);
}
```

Отже на даному етапі я маємо таку логіку кожного циклу: прінтимо промт, читаємо срічку з stdin, парсимо цю стрічку в окремі команди, виконуємо розпаршені команди. Це - той фундамент, на якому я будемо будувати подальшу логіку програми. Звісно, в майбутньому я не уникну рефакторингу, адже більш складні рішення вимагають чіткої і стуктурованої архітектури. Проте для поточної задачі цього цілком достатньо. 
#### Читання стрічки

Для читання стрічки я вирішив використати метод з читанням по-символьно в буфер, котрий має деякий стандартний розмір. Цей розмір, звісно, збільшується, якщо стрічка не вміщаєтсья. Хоча я не вважаю, що цей метод найбільш ефективний, проте, по перше, він простий, по друге, я не знайшов поки рішення, як зробити буфер динамічним не використовуючи `realloc`.  Функція виглядає наступним чином:
```C
char *msh_read_line() {
    int c;
    int n = 0;
    int bufsize = DEFAULT_BUFSIZE;

    char *line = (char *)malloc(DEFAULT_BUFSIZE * sizeof(char));
    if (!line) {
        fprintf(stderr, "msh: allocation error\n");
        exit(EXIT_FAILURE);
    }

    while (1) {
        c = getchar();
        if (c == EOF || c == '\n') {
            line[n] = '\0';
            return line;
        }

        line[n++] = c;

        if (n >= DEFAULT_BUFSIZE) {
            bufsize += DEFAULT_BUFSIZE;
            line = realloc(line, bufsize * sizeof(char));
            if (!line) {
                fprintf(stderr, "msh: allocation error\n");
                exit(EXIT_FAILURE);
            }
        }
    }
}
```
Логіка доволі прямолінійна. Напочатку ми ініціалізуємо буфер, виділяючи пам'ять під `DEFAULT_BUFSIZE` символів `char`. Звісно, не забуваємо перевірити вказівник на випадок, якщо виділення пам'яті невдале. Після цього, заходимо в цикл, в якому ми по-символьно читаємо кожну ітерацію. Власне читання відбувається за допомогою стандартної функції `getchar()`. Одразу після читання перевіряємо чи не є цей символ ознакою закінчення рядка, якщо так - закінчуємо роботу і віддаємо стрічку далі. Якщо ж ні - записуємо його в буфер. Наступний блок, це те місце, про яке я довго думав, проте не знайшов більш підходящого рішення на поточному етапі. Отже на цьому кроці ми перевіряємо: чи не виходимо ми за межі нашого буфера? Якщо ж так - збільшуємо розмір нашого буфера шляхом перевиділення більшої кількості пам'яті. То чому ж я хотів уникнути цих дій?Справа в тому, що саме по собі динамічне виділення пам'яті не є лекгою операцією, адже вимагає системних викликів `brk` `sbrk`, заглядання в free-list і т.д. Що вже і казати за перевиділення. Тому я хотів бм обійти цей шлях. Але залишимо це на потім...
