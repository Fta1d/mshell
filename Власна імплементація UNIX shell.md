#### Життєвий цикл shell
1. Ініціалізація
	На цьому етапі shell зчитує конфігураційні файли та змінює свою поведінку відповідно до них.
2. Виконання
	Тут оболонка читає та виконує команди з stdin або файлу.
3. Завершення
	Після того, як всі команди виконані shell виконує всі кроки(команди) завершення роботи, звільняє пам'ять та закінчує процес.

Взагалі ці кроки життєвого циклу настільки узанілтнені, що можуть бути застосовані до, буквально, будь-якої програми. В даному випадку моя оболонка буде дещо зпрощена. Вона не буде мати конфігураційних файлів та команд завершення. На першому етапі mshell буде складатись з основного чиклу роботи в якому будуть виконуватись команди, що вводяться вручну. Хоча, на кроці проектування архітектури програми варто продумати наперед можливість розширення функціональності, що в себе включє вище згадані конф. файли та shutdown commands. 

```C 
int main(char **argv, int argc) {
	// TODO: Load configuration files
	
	// Main shell loop
	mshell_loop();
	
	// TODO: Execute termination routines
	
	return 0;
}
```
Вище можна побачити базову структкру програми. Моя програма буде складатись з основного циклу `mshell_loop()` в якому відбуватимуться всі необхідні операції для виконання команд. В наступних параграфах ми більш детально їх оглянемо. 
#### Основний цикл shell
В попередньому параграфі ми обговорили: як повинна запускатись програма, що вона повинна виконувати під час роботи, так як завершуватись. Отже, що нам потрібно для базового функціонування shell? Що конкретно shell робить під час циклу? Власне найпростіша імплементація оболонки включає в себе такі три кроки:
- Read: читання команд з stdin.
- Parse: розділення стрічки команди на програму та її аргументи.
- Execute: виконання визначених команд.
```C
void mshell_loop() {
	char *line;
	char **args;
	int8_t status;
	
	do {
		printf("> ");
		line = mshell_read_line();
		args = mshell_split_line(line);
		status = mshell_execute(args);
		  
		free(line);
		free(args);
	} while (status);
}
```

Отже на даному етапі я маємо таку логіку кожного циклу: прінтимо промт, читаємо срічку з stdin, парсимо цю стрічку в окремі команди, виконуємо розпаршені команди. Це - той фундамент, на якому я будемо будувати подальшу логіку програми. Звісно, в майбутньому я не уникну рефакторингу, адже більш складні рішення вимагають чіткої і стуктурованої архітектури. Проте для поточної задачі цього цілком достатньо. 
#### Читання стрічки

 